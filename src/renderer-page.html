<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Renderer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- MapLibre CSS is optional for headless rendering; controls are disabled. -->
  <style>
    html, body { margin: 0; height: 100%; background: #000; }
    #map { position: absolute; inset: 0; }
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- Scripts are injected by Puppeteer (server) to avoid cross-site blockers. -->

  <script>
    // --- Shared Animation Core Functions (inline version) ---
    // Utility: WebGL availability check
    function isWebglSupported() {
      const c = document.createElement('canvas');
      const gl = c.getContext('webgl2') || c.getContext('webgl');
      return !!(gl && typeof gl.getParameter === 'function');
    }

    // --- Utility: linear interpolate between keyframes
    function lerp(a, b, t) { return a + (b - a) * t; }
    function lerpFrame(a, b, t) {
      return {
        center: [lerp(a.center[0], b.center[0], t), lerp(a.center[1], b.center[1], t)],
        zoom: lerp(a.zoom, b.zoom, t),
        bearing: lerp(a.bearing ?? 0, b.bearing ?? 0, t),
        pitch: lerp(a.pitch ?? 0, b.pitch ?? 0, t)
      };
    }
    const EASING = {
      linear: (x) => x,
      easeOutCubic: (x) => 1 - Math.pow(1 - x, 3),
      easeInOutCubic: (x) => (x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2),
      easeOutQuad: (x) => 1 - (1 - x) * (1 - x)
    };
    function findSpan(keyframes, t) {
      let i = 0;
      while (i < keyframes.length - 1 && t > keyframes[i + 1].t) i++;
      return [i, Math.min(i + 1, keyframes.length - 1)];
    }

    // Color helpers
    function getBorderColor(p) { return (p?.border?.color) || '#ffcc00'; }
    function getTraceColor(p) { return (p?.border?.traceColor) || '#ffffff'; }
    function getTraceDelta(p) { return Math.max(0, Number(p?.border?.traceWidthDelta ?? 1)); }
    function toLngLatArray(c) {
      if (!c) return undefined;
      if (Array.isArray(c) && c.length >= 2 && isFinite(c[0]) && isFinite(c[1])) return [Number(c[0]), Number(c[1])];
      if (typeof c === 'object' && c !== null) {
        const lng = c.lng ?? c.lon ?? c.longitude;
        const lat = c.lat ?? c.latitude;
        if (isFinite(lng) && isFinite(lat)) return [Number(lng), Number(lat)];
      }
      return undefined;
    }

    // --- Shared Map Core Functions (inline version) ---
    // Build linework from polygons for crisp outlines and tracing
    function polygonToLines(fc) {
      const out = { type: 'FeatureCollection', features: [] };
      for (const f of fc.features) {
        const g = f.geometry;
        const props = f.properties || {};
        if (!g) continue;
        if (g.type === 'Polygon') {
          for (const ring of g.coordinates) {
            out.features.push({ type: 'Feature', properties: props, geometry: { type: 'LineString', coordinates: ring } });
          }
        } else if (g.type === 'MultiPolygon') {
          for (const poly of g.coordinates) {
            for (const ring of poly) {
              out.features.push({ type: 'Feature', properties: props, geometry: { type: 'LineString', coordinates: ring } });
            }
          }
        }
      }
      return out;
    }

    // Filter border data by ISO3 code  
    function filterBordersByISO3(borderData, ISO3) {
      const feats = borderData.features.filter(f => {
        const p = f.properties || {};
        return [p.ADM0_A3, p.ISO_A3, p["ISO3166-1-Alpha-3"], p.iso_a3]
          .map(x => (x || "").toString().toUpperCase())
          .includes(ISO3);
      });
      
      let matched = feats;
      if (!matched.length) {
        // Fallback: match by 'name' using a small ISO3->Name map (helps with world-atlas datasets)
        const isoToName = { 
          ESP: 'Spain', FRA: 'France', DEU: 'Germany', ITA: 'Italy', GBR: 'United Kingdom', 
          USA: 'United States of America', MEX: 'Mexico', CAN: 'Canada', BRA: 'Brazil', 
          AUS: 'Australia', JPN: 'Japan', CHN: 'China', IND: 'India', RUS: 'Russia' 
        };
        const target = (isoToName[ISO3] || '').toUpperCase();
        if (target) {
          matched = borderData.features.filter(f => ((f.properties?.name || '').toString().toUpperCase()) === target);
          if (!matched.length) {
            // Some datasets use NAME or NAME_EN
            matched = borderData.features.filter(f => {
              const p = f.properties || {};
              return [p.NAME, p.NAME_EN, p.name_long].map(x => (x||'').toString().toUpperCase()).includes(target);
            });
          }
          console.log(`[renderer] fallback name match for ${ISO3}=${target} features=${matched.length}`);
        }
      }
      console.log(`[renderer] border match iso3=${ISO3} features=${matched.length}`);
      
      return { type: "FeatureCollection", features: matched };
    }

    // --- Terrain, boundary fill, and deck overlay helpers ---
    async function enableTerrain(map, exaggeration) {
      try {
        if (!map.getSource('terrain-src')) {
          map.addSource('terrain-src', { type: 'raster-dem', url: 'https://demotiles.maplibre.org/terrain-tiles/tiles.json', tileSize: 256 });
        }
        map.setTerrain({ source: 'terrain-src', exaggeration: exaggeration || 1.2 });
        if (!map.getLayer('sky')) {
          map.addLayer({ id: 'sky', type: 'sky', paint: { 'sky-type': 'atmosphere', 'sky-atmosphere-sun-intensity': 10 } });
        }
      } catch (e) { console.warn('[renderer] enableTerrain failed', e?.message || e); }
    }
    async function addBoundaryFill(map, geojson, fill, fillOpacity, lineColor, lineWidth) {
      try {
        if (!map.getSource('boundary-src')) map.addSource('boundary-src', { type: 'geojson', data: geojson });
        else map.getSource('boundary-src').setData(geojson);
        if (!map.getLayer('boundary-fill')) {
          map.addLayer({ id:'boundary-fill', type:'fill', source:'boundary-src', paint:{ 'fill-color': fill || '#ffcc00', 'fill-opacity': (typeof fillOpacity === 'number') ? fillOpacity : 0.25 } });
        }
        if (!map.getLayer('boundary-line')) {
          map.addLayer({ id:'boundary-line', type:'line', source:'boundary-src', paint:{ 'line-color': lineColor || '#ffcc00', 'line-width': (typeof lineWidth === 'number') ? lineWidth : 2 } });
        }
      } catch (e) { console.warn('[renderer] addBoundaryFill failed', e?.message || e); }
    }
    async function addGoogle3DTiles(map, apiKey, opacity) {
      try {
        const overlay = new deck.MapboxOverlay({ interleaved: true, layers: [ new deck.Tile3DLayer({ id:'google-3d', data:`https://tile.googleapis.com/v1/3dtiles/root.json?key=${apiKey}`, opacity: (typeof opacity === 'number') ? opacity : 1 }) ] });
        map.addControl(overlay);
        return overlay;
      } catch (e) { console.warn('[renderer] deck.gl not available', e?.message || e); return null; }
    }

    async function runZoomPhase(map, encoder, program, fps, duration, frameCount, ease) {
      for (let i = 0; i < frameCount; i++) {
        const p = i / Math.max(1, frameCount - 1);
        const t = ease(p) * duration; // ms
        const [aIdx, bIdx] = findSpan(program.camera.keyframes, t);
        const a = program.camera.keyframes[aIdx];
        const b = program.camera.keyframes[bIdx];
        const tt = a.t === b.t ? 0 : (t - a.t) / (b.t - a.t);
        const pose = lerpFrame(a, b, tt);
        map.jumpTo({ center: [pose.center[0], pose.center[1]], zoom: pose.zoom, bearing: pose.bearing, pitch: pose.pitch });
        const waitForTiles = program.output.waitForTiles;
        if (waitForTiles === false) await new Promise(res => requestAnimationFrame(res));
        else await new Promise(res => map.once("idle", res));
        await encoder.add(map.getCanvas());
        if (i % Math.max(30, Math.floor(frameCount / 10)) === 0 || i === frameCount - 1) {
          const done = i + 1; const left = frameCount - done; const pct = Math.round((done / frameCount) * 100);
          console.log(`[progress] frames ${done}/${frameCount} (${pct}%), left=${left}`);
        }
      }
    }

    async function runWaitPhase(map, encoder, ms, fps) {
      const frames = Math.ceil((ms / 1000) * fps);
      for (let i = 0; i < frames; i++) {
        await new Promise(res => requestAnimationFrame(res));
        await encoder.add(map.getCanvas());
      }
    }

    async function runTracePhase(map, encoder, program, fps) {
      console.log("tracing border")
      const traceMs = program.border?.traceDurationMs ?? 3000;
      const traceFrames = Math.max(1, Math.ceil((traceMs / 1000) * fps));
      console.log(`[progress] trace-start: frames=${traceFrames}, ms=${traceMs}`);
      const traceEvery = Math.max(15, Math.floor(traceFrames / 5));
      const showDuringZoom = !!(program.border?.showDuringZoom);
      const borderOpacity = program.border?.opacity ?? 1;

      if (!showDuringZoom) {
        try { map.setPaintProperty('border_line', 'line-opacity', 0); } catch {}
        try { map.setPaintProperty('border_drawn', 'line-opacity', 0); } catch {}
      }

      for (let j = 0; j < traceFrames; j++) {
        const prog = j / Math.max(1, traceFrames - 1) + 0.03;
        const gradTrace = [ 'interpolate', ['linear'], ['line-progress'], 0, 'rgba(255,255,255,0.0)', Math.max(0, prog - 0.02), 'rgba(255,255,255,0.0)', prog, 'rgba(255,255,255,1.0)', Math.min(1, prog + 0.02), 'rgba(255,255,255,0.0)', 1, 'rgba(255,255,255,0.0)' ];
        const borderCol = getBorderColor(program);
        const gradDrawn = [ 'interpolate', ['linear'], ['line-progress'], 0, borderCol, Math.max(0, prog), borderCol, Math.min(1, prog + 0.001), 'rgba(255,204,0,0.0)', 1, 'rgba(255,204,0,0.0)' ];
        try {
          map.setPaintProperty('border_trace', 'line-gradient', gradTrace);
          map.setPaintProperty('border_trace', 'line-color', getTraceColor(program));
          map.setPaintProperty('border_trace', 'line-opacity', 1.0);
          map.setPaintProperty('border_drawn', 'line-gradient', gradDrawn);
          map.setPaintProperty('border_drawn', 'line-opacity', borderOpacity);
        } catch (e) {
          console.error('[renderer] trace setPaintProperty error', e?.message || e);
          try {
            map.setPaintProperty('border_trace', 'line-gradient', undefined);
            map.setPaintProperty('border_trace', 'line-color', getTraceColor(program));
            map.setPaintProperty('border_trace', 'line-opacity', 1.0);
            map.setPaintProperty('border_drawn', 'line-gradient', undefined);
            map.setPaintProperty('border_drawn', 'line-color', borderCol);
            map.setPaintProperty('border_drawn', 'line-opacity', borderOpacity);
          } catch (e2) { console.error('[renderer] trace fallback error', e2?.message || e2); }
        }
        await new Promise(res => map.once('idle', res));
        await encoder.add(map.getCanvas());
        if (j % traceEvery === 0 || j === traceFrames - 1) {
          const done = j + 1; const left = traceFrames - done; const pct = Math.round((done / traceFrames) * 100);
          console.log(`[progress] trace ${done}/${traceFrames} (${pct}%), left=${left}`);
        }
      }
      try { map.setPaintProperty('border_trace', 'line-opacity', 0.0); } catch {}
      const showAfter = (program.border?.showStaticAfterTrace !== false);
      if (showAfter) {
        try {
          map.setPaintProperty('border_drawn', 'line-gradient', undefined);
          map.setPaintProperty('border_drawn', 'line-color', getBorderColor(program));
          map.setPaintProperty('border_drawn', 'line-opacity', borderOpacity);
          console.log('[renderer] static border set after trace');
        } catch (e) { console.error('[renderer] reveal static border error', e?.message || e); }
      }
    }

    async function runHoldPhase(map, encoder, program, fps) {
      const holdMs = Math.max(0, Number(program.border?.traceHoldMs ?? 2000));
      const holdFrames = Math.ceil((holdMs / 1000) * fps);
      if (holdFrames > 0) {
        console.log(`[progress] hold-start: frames=${holdFrames}, ms=${holdMs}`);
        for (let h = 0; h < holdFrames; h++) {
          await new Promise(res => requestAnimationFrame(res));
          await encoder.add(map.getCanvas());
        }
        console.log('[progress] hold-done');
      }
    }

    // This is called by Puppeteer: window.startRender(program)
    window.startRender = async function(program) {
      const width = program.output.width, height = program.output.height;
      const fps = program.output.fps;
      const duration = program.camera.keyframes.at(-1).t;
      const easeName = program.animation?.easing || 'easeOutCubic';
      const ease = EASING[easeName] || EASING.easeOutCubic;
      const frameCount = Math.ceil((duration / 1000) * fps);

      // Resize container so MapLibre canvas uses exact output size
      const mapDiv = document.getElementById("map");
      // Reset container for pooled pages
      mapDiv.innerHTML = "";
      mapDiv.style.width = width + "px";
      mapDiv.style.height = height + "px";

      // Default style (no token required). For best results, supply a high-res satellite style URL via program.style.
      const styleUrl = program.style || "https://demotiles.maplibre.org/style.json";

      // Create map
      const map = new maplibregl.Map({
        container: "map",
        style: styleUrl,
        interactive: false,
        attributionControl: false,
        // Ask MapLibre for a context that works for capture + headless
        canvasContextAttributes: {
          // Force WebGL1 for better headless stability
          contextType: "webgl",
          // Needed for reliable frame capture
          preserveDrawingBuffer: true,
          // These mirror MapLibre defaults; safe to keep
          antialias: true,
          powerPreference: "high-performance",
          failIfMajorPerformanceCaveat: false,
          desynchronized: false
        },
        // Render at higher pixel density for crisp lines/labels
        pixelRatio: Math.max(1, Math.min(4, Number(program.output.pixelRatio) || 2))
      });

      // Add border highlight source + layer after 'load'
      await new Promise(res => map.on("load", res));
      try { console.log('[renderer] maplibre version=', maplibregl.version, 'style.version=', (map.getStyle()||{}).version); } catch {}
      // Borders: ask Node side to provide GeoJSON (local file or server-side fetch)
      const borderData = await window.__nodeGetBordersGeoJSON();

      // Filter the feature for the requested ISO3 using shared function
      const ISO3 = (program.border?.isoA3 || '').toString().toUpperCase();
      const highlight = filterBordersByISO3(borderData, ISO3);
      map.addSource("border_src", { type: "geojson", data: highlight });

      // Prefer program.boundaryGeoJSON for outlines/tracing if provided; otherwise use country highlight
      let borderLines = null;
      if (program.boundaryGeoJSON && program.boundaryGeoJSON.type) {
        const gj = program.boundaryGeoJSON;
        if (gj.type === 'FeatureCollection') {
          // If already lines, use as-is; if polygons, convert to lines
          const hasLine = (gj.features||[]).some(f => f.geometry?.type?.includes('Line'));
          borderLines = hasLine ? gj : polygonToLines(gj);
        } else {
          borderLines = gj;
        }
      } else {
        borderLines = polygonToLines(highlight);
      }
      console.log(`[renderer] border polygons=${highlight.features.length}, lineFeatures=${borderLines.features.length}`);
      try {
        map.addSource("border_lines_src", { type: 'geojson', data: borderLines, lineMetrics: true });
      } catch (e) { console.error('[renderer] addSource border_lines_src error', e?.message || e); }

      // Base border outline (initially hidden unless showDuringZoom)
      try { map.addLayer({
        id: "border_line",
        type: "line",
        source: "border_lines_src",
        paint: {
          "line-color": getBorderColor(program),
          "line-width": program.border?.strokeWidth ?? 4,
          // Start hidden; we will reveal after trace unless showDuringZoom is true
          "line-opacity": 0,
          "line-blur": 0
        },
        layout: {
          "line-join": "round",
          "line-cap": "round"
        }
      }); console.log('[renderer] added layer border_line'); } catch (e) { console.error('[renderer] addLayer border_line error', e?.message || e); }

      // Respect showDuringZoom: optionally show faint/visible outline during camera move
      const showDuringZoom = !!(program.border?.showDuringZoom);
      try {
        map.setPaintProperty('border_line', 'line-opacity', showDuringZoom ? (program.border?.opacity ?? 1) : 0);
        console.log(`[renderer] border_line initial opacity set to ${showDuringZoom ? (program.border?.opacity ?? 1) : 0}`);
      } catch (e) { console.error('[renderer] set opacity border_line error', e?.message || e); }

      // Disable transitions to avoid flashes
      try { map.setPaintProperty('border_line', 'line-opacity-transition', { duration: 0, delay: 0 }); } catch {}

      // Drawn border layer (progressively revealed via line-gradient)
      try { map.addLayer({
        id: 'border_drawn',
        type: 'line',
        source: 'border_lines_src',
        paint: {
          'line-color': getBorderColor(program),
          'line-width': (program.border?.strokeWidth ?? 4),
          'line-opacity': 0.0
        },
        layout: { 'line-join': 'round', 'line-cap': 'round' }
      }); console.log('[renderer] added layer border_drawn'); } catch (e) { console.error('[renderer] addLayer border_drawn error', e?.message || e); }
      try { map.setPaintProperty('border_drawn', 'line-opacity-transition', { duration: 0, delay: 0 }); } catch {}
      try { map.setPaintProperty('border_drawn', 'line-gradient-transition', { duration: 0, delay: 0 }); } catch {}

      // Trace layer (animated moving highlight)
      try { map.addLayer({
        id: 'border_trace',
        type: 'line',
        source: 'border_lines_src',
        paint: {
          'line-color': getTraceColor(program),
          'line-width': (program.border?.strokeWidth ?? 4) + getTraceDelta(program),
          'line-opacity': 0.0
        },
        layout: { 'line-join': 'round', 'line-cap': 'round' }
      }); console.log('[renderer] added layer border_trace'); } catch (e) { console.error('[renderer] addLayer border_trace error', e?.message || e); }
      try { map.setPaintProperty('border_trace', 'line-opacity-transition', { duration: 0, delay: 0 }); } catch {}
      try { map.setPaintProperty('border_trace', 'line-gradient-transition', { duration: 0, delay: 0 }); } catch {}

      // Label restriction util
      function applyLabelRestriction() {
        try {
          const geom = highlight.features[0]?.geometry;
          if (!geom) return;
          const style = map.getStyle();
          if (!style || !style.layers) return;
          for (const layer of style.layers) {
            if (layer.type === 'symbol') {
              map.setFilter(layer.id, ['within', { type: geom.type, coordinates: geom.coordinates }]);
            }
          }
        } catch (e) { /* ignore */ }
      }

      // Optional: boundary fill/outline if provided by server
      if (program.boundaryGeoJSON) {
        await addBoundaryFill(map, program.boundaryGeoJSON, program.boundaryFill, 0 /* start invisible for highlight phase */, program.boundaryLineColor, 0 /* start invisible */);
      } else {
        // If no boundaryGeoJSON but we have country highlight polygons, add a fill for them too (start invisible)
        try {
          if (!map.getSource('country-fill-src')) map.addSource('country-fill-src', { type: 'geojson', data: highlight });
          if (!map.getLayer('country-fill')) map.addLayer({ id:'country-fill', type:'fill', source:'country-fill-src', paint:{ 'fill-color': program.boundaryFill || '#ffcc00', 'fill-opacity': 0 } });
          if (!map.getLayer('country-outline')) map.addLayer({ id:'country-outline', type:'line', source:'country-fill-src', paint:{ 'line-color': program.boundaryLineColor || getBorderColor(program), 'line-width': program.boundaryLineWidth || 2, 'line-opacity': 0 } });
        } catch (e) { console.warn('[renderer] add country fill failed', e?.message || e); }
      }

      // Optional: terrain/sky
      if (program.flags?.terrain) await enableTerrain(map, program.flags?.terrainExaggeration || 1.2);

      // Warm up one render
      if (program.labels?.restrictToCountry && program.labels?.applyAt === 'always') {
        applyLabelRestriction();
      }
      await new Promise(res => map.once("idle", res));

      // Encoder selection: raw RGBA frames -> Node (ffmpeg) if provided, else fallback to Hubble WebM
      const useRgbaPath = typeof window.__nodeDeliverFrameRGBA === 'function';
      let encoder;
      if (useRgbaPath) {
        const canvas = map.getCanvas();
        const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
        if (!gl) throw new Error('WebGL context required for RGBA readback');
        const capW = canvas.width | 0;
        const capH = canvas.height | 0;
        const buf = new Uint8Array(capW * capH * 4);
        encoder = {
          async start() {},
          async add() {
            gl.readPixels(0, 0, capW, capH, gl.RGBA, gl.UNSIGNED_BYTE, buf);
            await window.__nodeDeliverFrameRGBA(buf);
          },
          async save() { return null; }
        };
        await encoder.start();
      } else {
        const hub = window.hubble || window.Hubble || window.hubblegl || window.HubbleGL || {};
        const WebMEncoder = hub.WebMEncoder || hub.WebmEncoder;
        if (typeof WebMEncoder !== 'function') {
          const keys = Object.keys(hub);
          throw new Error('Hubble.gl WebMEncoder not found. Exports: ' + JSON.stringify(keys));
        }
        encoder = new WebMEncoder({ framerate: fps });
        await encoder.start();
      }
      // Optional: deck.gl overlay for Google Photorealistic 3D Tiles
      let deckOverlay = null;
      if (program.flags?.google3dApiKey) {
        deckOverlay = await addGoogle3DTiles(map, program.flags.google3dApiKey, program.flags?.google3dOpacity ?? 1);
      }
      // Progress logging header
      const effPixelRatio = Math.max(1, Math.min(4, Number(program.output.pixelRatio) || 2));
      console.log(`[progress] start: frames=${frameCount}, fps=${fps}, waitForTiles=${program.output.waitForTiles}, pixelRatio=${effPixelRatio}`);
      const progressEvery = Math.max(30, Math.floor(frameCount / 10));

      // If segments are present, run them in order (per-segment boundary + phases)
      if (Array.isArray(program.segments) && program.segments.length) {
        for (const seg of program.segments) {
          try {
            // Update boundary fills and lines to this segment's geometry
            const segFC = (seg.boundaryGeoJSON && seg.boundaryGeoJSON.type === 'FeatureCollection') ? seg.boundaryGeoJSON : null;
            if (segFC) {
              try {
                if (map.getSource('boundary-src')) map.getSource('boundary-src').setData(segFC);
                else map.addSource('boundary-src', { type: 'geojson', data: segFC });
                // Convert polygons to lines for tracing
                const hasLine = (segFC.features||[]).some(f => f.geometry?.type?.includes('Line'));
                const borderLines = hasLine ? segFC : polygonToLines(segFC);
                if (map.getSource('border_lines_src')) map.getSource('border_lines_src').setData(borderLines);
                else map.addSource('border_lines_src', { type: 'geojson', data: borderLines, lineMetrics: true });
              } catch (e) { console.warn('[renderer] segment boundary set failed', e?.message || e); }
            }
            // Reset visibilities
            try {
              if (map.getLayer('boundary-fill')) map.setPaintProperty('boundary-fill', 'fill-opacity', 0);
              if (map.getLayer('boundary-line')) map.setPaintProperty('boundary-line', 'line-opacity', 0);
              if (map.getLayer('country-fill')) map.setPaintProperty('country-fill', 'fill-opacity', 0);
              if (map.getLayer('country-outline')) map.setPaintProperty('country-outline', 'line-opacity', 0);
              if (map.getLayer('border_drawn')) map.setPaintProperty('border_drawn', 'line-opacity', 0);
              if (map.getLayer('border_trace')) map.setPaintProperty('border_trace', 'line-opacity', 0);
            } catch {}

            // Phases + timing per segment
            const segPhases = (seg.phases && seg.phases.length) ? seg.phases : (program.animation?.phases || ['zoom','highlight','trace','hold']);
            const segDuration = seg.camera.keyframes.at(-1).t;
            const segFrameCount = Math.ceil((segDuration / 1000) * fps);
            const easeName2 = program.animation?.easing || 'easeOutCubic';
            const ease2 = EASING[easeName2] || EASING.easeOutCubic;
            // Run phases
            for (const phase of segPhases) {
              if (phase === 'zoom') await runZoomPhase(map, { ...program, ...seg }, fps, segDuration, segFrameCount, ease2, encoder);
              else if (phase === 'highlight') await runHighlightPhase(map, { ...program, ...seg }, fps, encoder);
              else if (phase === 'wait') await runWaitPhase(map, Number(program.animation?.waitBeforeTraceMs || 0), fps, encoder);
              else if (phase === 'trace') await runTracePhase(map, { ...program, ...seg }, fps, encoder);
              else if (phase === 'hold') await runHoldPhase(map, { ...program, ...seg }, fps, encoder);
            }
          } catch (e) { console.error('[renderer] segment run failed', e?.message || e); }
        }
        // Save & deliver
        if (typeof window.__nodeDeliverFrameRGBA === 'function') {
          if (typeof window.__nodeDeliverEnd === 'function') await window.__nodeDeliverEnd();
        } else {
          const blob = await encoder.save();
          const arrbuf = await blob.arrayBuffer();
          const byteArray = Array.from(new Uint8Array(arrbuf));
          await window.__nodeDeliverWebM(byteArray);
        }
        try { deckOverlay?.finalize?.(); } catch {}
        return;
      }

      // Optional auto-fit for final keyframe framing (prefer boundaryGeoJSON if provided)
      try {
        if (program.animation?.fitFinalToBorder) {
          let geom = null;
          if (program.boundaryGeoJSON && program.boundaryGeoJSON.type === 'FeatureCollection' && program.boundaryGeoJSON.features?.length) {
            geom = program.boundaryGeoJSON.features[0].geometry;
          } else if (highlight.features?.length) {
            geom = highlight.features[0].geometry;
          }
          if (geom) {
            const coords = (geom.type === 'Polygon') ? geom.coordinates.flat(1) : geom.coordinates.flat(2);
            const lons = coords.map(c => c[0]);
            const lats = coords.map(c => c[1]);
            const minLon = Math.min(...lons), maxLon = Math.max(...lons);
            const minLat = Math.min(...lats), maxLat = Math.max(...lats);
            const pad = Number(program.animation?.fitPaddingPx ?? 80);
            const cam = map.cameraForBounds([[minLon, minLat],[maxLon, maxLat]], { padding: pad });
            if (cam && program.camera?.keyframes?.length) {
              const last = program.camera.keyframes[program.camera.keyframes.length - 1];
              const arr = toLngLatArray(cam.center);
              if (arr) last.center = arr;
              if (isFinite(cam.zoom)) last.zoom = cam.zoom;
            }
          }
        }
      } catch (e) { console.warn('[renderer] auto-fit final camera failed', e?.message || e); }

      // Execute phases in declared order
      const phases = (program.animation?.phases && program.animation.phases.length) ? program.animation.phases : ['zoom','trace','hold'];
      console.log("phases are", phases)
      for (const phase of phases) {
        console.log("current phase is", phase)
        if (phase === 'zoom') await runZoomPhase(map, encoder, program, fps, duration, frameCount, ease);
        else if (phase === 'highlight') {
          // Animate boundary fill/outline opacity up
          const ms = Math.max(500, Number(program.animation?.highlightDurationMs || 1200));
          const frames = Math.ceil((ms / 1000) * fps);
          const targetFill = (typeof program.boundaryFillOpacity === 'number') ? program.boundaryFillOpacity : 0.25;
          const targetLine = 1;
          for (let i = 0; i < frames; i++) {
            const p = i / Math.max(1, frames - 1);
            const v = EASING.easeOutCubic(p);
            try {
              if (program.boundaryGeoJSON) {
                map.setPaintProperty('boundary-fill', 'fill-opacity', targetFill * v);
                map.setPaintProperty('boundary-line', 'line-opacity', targetLine * v);
              } else {
                map.setPaintProperty('country-fill', 'fill-opacity', targetFill * v);
                map.setPaintProperty('country-outline', 'line-opacity', targetLine * v);
              }
            } catch {}
            await new Promise(res => requestAnimationFrame(res));
            await encoder.add(map.getCanvas());
          }
        }
        else if (phase === 'wait') await runWaitPhase(map, encoder, Number(program.animation?.waitBeforeTraceMs || 0), fps);
        else if (phase === 'trace') await runTracePhase(map, encoder, program, fps);
        else if (phase === 'hold') await runHoldPhase(map, encoder, program, fps);
      }

      // After zoom completes, optionally restrict labels and draw tracing
    //   if (program.labels?.restrictToCountry && (program.labels?.applyAt !== 'always')) {
    //     console.log("country label restriction")
    //     applyLabelRestriction();
    //     await new Promise(res => map.once('idle', res));
    //   }
    //   if (program.border?.traceAfterZoom) {
    //     console.log("tracing border")
    //     const traceMs = program.border?.traceDurationMs ?? 3000;
    //     const traceFrames = Math.max(1, Math.ceil((traceMs / 1000) * fps));
    //     console.log(`[progress] trace-start: frames=${traceFrames}, ms=${traceMs}`);
    //     const traceEvery = Math.max(15, Math.floor(traceFrames / 5));
    //     // Ensure static outline is hidden during trace if not supposed to showDuringZoom
    //     if (!showDuringZoom) {
    //       try { map.setPaintProperty('border_line', 'line-opacity', 0); } catch {}
    //       // Keep border_drawn hidden until gradient is applied to avoid flash
    //       try { map.setPaintProperty('border_drawn', 'line-opacity', 0); } catch {}
    //     }
    //     for (let j = 0; j < traceFrames; j++) {
    //       const prog = (j / Math.max(1, traceFrames - 1) ) + 0.03;
    //       const gradTrace = [
    //         'interpolate', ['linear'], ['line-progress'],
    //         0, 'rgba(255,255,255,0.0)',
    //         Math.max(0, prog - 0.02), 'rgba(255,255,255,0.0)',
    //         prog, 'rgba(255,255,255,1.0)',
    //         Math.min(1, prog + 0.02), 'rgba(255,255,255,0.0)',
    //         1, 'rgba(255,255,255,0.0)'
    //       ];
    //       const gradDrawn = [
    //         'interpolate', ['linear'], ['line-progress'],
    //         0, 'rgba(255,204,0,1.0)',
    //         Math.max(0, prog), 'rgba(255,204,0,1.0)',
    //         Math.min(1, prog + 0.001), 'rgba(255,204,0,0.0)',
    //         1, 'rgba(255,204,0,0.0)'
    //       ];
    //       try {
    //         map.setPaintProperty('border_trace', 'line-gradient', gradTrace);
    //         map.setPaintProperty('border_trace', 'line-opacity', 1.0);
    //         // progressively reveal the drawn border behind the tracer
    //         map.setPaintProperty('border_drawn', 'line-gradient', gradDrawn);
    //         map.setPaintProperty('border_drawn', 'line-opacity', program.border?.opacity ?? 1);
    //       } catch (e) {
    //         console.error('[renderer] trace setPaintProperty error', e?.message || e);
    //         // Fallback: show static trace if gradient not supported
    //         try {
    //           map.setPaintProperty('border_trace', 'line-gradient', undefined);
    //           map.setPaintProperty('border_trace', 'line-color', '#ffffff');
    //           map.setPaintProperty('border_trace', 'line-opacity', 1.0);
    //           // Show static border fully if gradient not supported
    //           map.setPaintProperty('border_drawn', 'line-gradient', undefined);
    //           map.setPaintProperty('border_drawn', 'line-color', '#ffcc00');
    //           map.setPaintProperty('border_drawn', 'line-opacity', program.border?.opacity ?? 1);
    //         } catch (e2) {
    //           console.error('[renderer] trace fallback error', e2?.message || e2);
    //         }
    //       }
    //       await new Promise(res => map.once('idle', res));
    //       await encoder.add(map.getCanvas());
    //       if (j % traceEvery === 0 || j === traceFrames - 1) {
    //         const done = j + 1;
    //         const left = traceFrames - done;
    //         const pct = Math.round((done / traceFrames) * 100);
    //         console.log(`[progress] trace ${done}/${traceFrames} (${pct}%), left=${left}`);
    //       }
    //     }
    //     try { map.setPaintProperty('border_trace', 'line-opacity', 0.0); } catch {}
    //     // After tracing completes, ensure static border is fully visible (via border_drawn) if desired
    //     const showAfter = (program.border?.showStaticAfterTrace !== false);
    //     if (showAfter) {
    //       try {
    //         map.setPaintProperty('border_drawn', 'line-gradient', undefined);
    //         map.setPaintProperty('border_drawn', 'line-color', '#ffcc00');
    //         map.setPaintProperty('border_drawn', 'line-opacity', program.border?.opacity ?? 1);
    //         console.log('[renderer] static border set after trace');
    //       } catch (e) { console.error('[renderer] reveal static border error', e?.message || e); }
    //     }

    //     // Hold for a few seconds after trace completes
    //     const holdMs = Math.max(0, Number(program.border?.traceHoldMs ?? 2000));
    //     const holdFrames = Math.ceil((holdMs / 1000) * fps);
    //     if (holdFrames > 0) {
    //       console.log(`[progress] hold-start: frames=${holdFrames}, ms=${holdMs}`);
    //       for (let h = 0; h < holdFrames; h++) {
    //         await new Promise(res => requestAnimationFrame(res));
    //         await encoder.add(map.getCanvas());
    //       }
    //       console.log('[progress] hold-done');
    //     }
    //   }

      if (typeof window.__nodeDeliverFrameRGBA === 'function') {
        if (typeof window.__nodeDeliverEnd === 'function') await window.__nodeDeliverEnd();
      } else {
        console.log('[progress] encode-save-start');
        const blob = await encoder.save(); // Blob (video/webm)
        console.log('[progress] encode-save-done bytes=' + (blob?.size ?? 'unknown'));
        const arrbuf = await blob.arrayBuffer();
        // Puppeteer binding is safer with plain arrays vs typed arrays.
        const byteArray = Array.from(new Uint8Array(arrbuf));
        console.log('[progress] deliver-bytes-start size=' + byteArray.length);
        await window.__nodeDeliverWebM(byteArray);
      }
      try { deckOverlay?.finalize?.(); } catch {}
      console.log('[progress] deliver-bytes-done');
    };
  </script>
</body>
</html>
