<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Renderer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- MapLibre CSS is optional for headless rendering; controls are disabled. -->
  <style>
    html, body { margin: 0; height: 100%; background: #000; }
    #map { position: absolute; inset: 0; }
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- Scripts are injected by Puppeteer (server) to avoid cross-site blockers. -->

  <script>
    // --- Utility: WebGL availability check
    function isWebglSupported() {
      const c = document.createElement('canvas');
      const gl = c.getContext('webgl2') || c.getContext('webgl');
      return !!(gl && typeof gl.getParameter === 'function');
    }

    // --- Utility: linear interpolate between keyframes
    function lerp(a, b, t) { return a + (b - a) * t; }
    function lerpFrame(a, b, t) {
      return {
        center: [lerp(a.center[0], b.center[0], t), lerp(a.center[1], b.center[1], t)],
        zoom: lerp(a.zoom, b.zoom, t),
        bearing: lerp(a.bearing ?? 0, b.bearing ?? 0, t),
        pitch: lerp(a.pitch ?? 0, b.pitch ?? 0, t)
      };
    }
    const EASING = {
      linear: (x) => x,
      easeOutCubic: (x) => 1 - Math.pow(1 - x, 3),
      easeInOutCubic: (x) => (x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2),
      easeOutQuad: (x) => 1 - (1 - x) * (1 - x)
    };
    function findSpan(keyframes, t) {
      let i = 0;
      while (i < keyframes.length - 1 && t > keyframes[i + 1].t) i++;
      return [i, Math.min(i + 1, keyframes.length - 1)];
    }

    // Helpers
    function getBorderColor(p) { return (p?.border?.color) || '#ffcc00'; }
    function getTraceColor(p) { return (p?.border?.traceColor) || '#ffffff'; }
    function getTraceDelta(p) { return Math.max(0, Number(p?.border?.traceWidthDelta ?? 1)); }
    function toLngLatArray(c) {
      if (!c) return undefined;
      if (Array.isArray(c) && c.length >= 2 && isFinite(c[0]) && isFinite(c[1])) return [Number(c[0]), Number(c[1])];
      if (typeof c === 'object' && c !== null) {
        const lng = c.lng ?? c.lon ?? c.longitude;
        const lat = c.lat ?? c.latitude;
        if (isFinite(lng) && isFinite(lat)) return [Number(lng), Number(lat)];
      }
      return undefined;
    }

    async function runZoomPhase(map, encoder, program, fps, duration, frameCount, ease) {
      for (let i = 0; i < frameCount; i++) {
        const p = i / Math.max(1, frameCount - 1);
        const t = ease(p) * duration; // ms
        const [aIdx, bIdx] = findSpan(program.camera.keyframes, t);
        const a = program.camera.keyframes[aIdx];
        const b = program.camera.keyframes[bIdx];
        const tt = a.t === b.t ? 0 : (t - a.t) / (b.t - a.t);
        const pose = lerpFrame(a, b, tt);
        map.jumpTo({ center: [pose.center[0], pose.center[1]], zoom: pose.zoom, bearing: pose.bearing, pitch: pose.pitch });
        const waitForTiles = program.output.waitForTiles;
        if (waitForTiles === false) await new Promise(res => requestAnimationFrame(res));
        else await new Promise(res => map.once("idle", res));
        await encoder.add(map.getCanvas());
        if (i % Math.max(30, Math.floor(frameCount / 10)) === 0 || i === frameCount - 1) {
          const done = i + 1; const left = frameCount - done; const pct = Math.round((done / frameCount) * 100);
          console.log(`[progress] frames ${done}/${frameCount} (${pct}%), left=${left}`);
        }
      }
    }

    async function runWaitPhase(map, encoder, ms, fps) {
      const frames = Math.ceil((ms / 1000) * fps);
      for (let i = 0; i < frames; i++) {
        await new Promise(res => requestAnimationFrame(res));
        await encoder.add(map.getCanvas());
      }
    }

    async function runTracePhase(map, encoder, program, fps) {
      console.log("tracing border")
      const traceMs = program.border?.traceDurationMs ?? 3000;
      const traceFrames = Math.max(1, Math.ceil((traceMs / 1000) * fps));
      console.log(`[progress] trace-start: frames=${traceFrames}, ms=${traceMs}`);
      const traceEvery = Math.max(15, Math.floor(traceFrames / 5));
      const showDuringZoom = !!(program.border?.showDuringZoom);
      const borderOpacity = program.border?.opacity ?? 1;

      if (!showDuringZoom) {
        try { map.setPaintProperty('border_line', 'line-opacity', 0); } catch {}
        try { map.setPaintProperty('border_drawn', 'line-opacity', 0); } catch {}
      }

      for (let j = 0; j < traceFrames; j++) {
        const prog = j / Math.max(1, traceFrames - 1) + 0.03;
        const gradTrace = [ 'interpolate', ['linear'], ['line-progress'], 0, 'rgba(255,255,255,0.0)', Math.max(0, prog - 0.02), 'rgba(255,255,255,0.0)', prog, 'rgba(255,255,255,1.0)', Math.min(1, prog + 0.02), 'rgba(255,255,255,0.0)', 1, 'rgba(255,255,255,0.0)' ];
        const borderCol = getBorderColor(program);
        const gradDrawn = [ 'interpolate', ['linear'], ['line-progress'], 0, borderCol, Math.max(0, prog), borderCol, Math.min(1, prog + 0.001), 'rgba(255,204,0,0.0)', 1, 'rgba(255,204,0,0.0)' ];
        try {
          map.setPaintProperty('border_trace', 'line-gradient', gradTrace);
          map.setPaintProperty('border_trace', 'line-color', getTraceColor(program));
          map.setPaintProperty('border_trace', 'line-opacity', 1.0);
          map.setPaintProperty('border_drawn', 'line-gradient', gradDrawn);
          map.setPaintProperty('border_drawn', 'line-opacity', borderOpacity);
        } catch (e) {
          console.error('[renderer] trace setPaintProperty error', e?.message || e);
          try {
            map.setPaintProperty('border_trace', 'line-gradient', undefined);
            map.setPaintProperty('border_trace', 'line-color', getTraceColor(program));
            map.setPaintProperty('border_trace', 'line-opacity', 1.0);
            map.setPaintProperty('border_drawn', 'line-gradient', undefined);
            map.setPaintProperty('border_drawn', 'line-color', borderCol);
            map.setPaintProperty('border_drawn', 'line-opacity', borderOpacity);
          } catch (e2) { console.error('[renderer] trace fallback error', e2?.message || e2); }
        }
        await new Promise(res => map.once('idle', res));
        await encoder.add(map.getCanvas());
        if (j % traceEvery === 0 || j === traceFrames - 1) {
          const done = j + 1; const left = traceFrames - done; const pct = Math.round((done / traceFrames) * 100);
          console.log(`[progress] trace ${done}/${traceFrames} (${pct}%), left=${left}`);
        }
      }
      try { map.setPaintProperty('border_trace', 'line-opacity', 0.0); } catch {}
      const showAfter = (program.border?.showStaticAfterTrace !== false);
      if (showAfter) {
        try {
          map.setPaintProperty('border_drawn', 'line-gradient', undefined);
          map.setPaintProperty('border_drawn', 'line-color', getBorderColor(program));
          map.setPaintProperty('border_drawn', 'line-opacity', borderOpacity);
          console.log('[renderer] static border set after trace');
        } catch (e) { console.error('[renderer] reveal static border error', e?.message || e); }
      }
    }

    async function runHoldPhase(map, encoder, program, fps) {
      const holdMs = Math.max(0, Number(program.border?.traceHoldMs ?? 2000));
      const holdFrames = Math.ceil((holdMs / 1000) * fps);
      if (holdFrames > 0) {
        console.log(`[progress] hold-start: frames=${holdFrames}, ms=${holdMs}`);
        for (let h = 0; h < holdFrames; h++) {
          await new Promise(res => requestAnimationFrame(res));
          await encoder.add(map.getCanvas());
        }
        console.log('[progress] hold-done');
      }
    }

    // This is called by Puppeteer: window.startRender(program)
    window.startRender = async function(program) {
      const width = program.output.width, height = program.output.height;
      const fps = program.output.fps;
      const duration = program.camera.keyframes.at(-1).t;
      const easeName = program.animation?.easing || 'easeOutCubic';
      const ease = EASING[easeName] || EASING.easeOutCubic;
      const frameCount = Math.ceil((duration / 1000) * fps);

      // Resize container so MapLibre canvas uses exact output size
      const mapDiv = document.getElementById("map");
      mapDiv.style.width = width + "px";
      mapDiv.style.height = height + "px";

      // Default style (no token required). For best results, supply a high-res satellite style URL via program.style.
      const styleUrl = program.style || "https://demotiles.maplibre.org/style.json";

      // Create map
      const map = new maplibregl.Map({
        container: "map",
        style: styleUrl,
        interactive: false,
        attributionControl: false,
        // Ask MapLibre for a context that works for capture + headless
        canvasContextAttributes: {
          // Force WebGL1 for better headless stability
          contextType: "webgl",
          // Needed for reliable frame capture
          preserveDrawingBuffer: true,
          // These mirror MapLibre defaults; safe to keep
          antialias: true,
          powerPreference: "high-performance",
          failIfMajorPerformanceCaveat: false,
          desynchronized: false
        },
        // Render at higher pixel density for crisp lines/labels
        pixelRatio: Math.max(1, Math.min(4, Number(program.output.pixelRatio) || 2))
      });

      // Add border highlight source + layer after 'load'
      await new Promise(res => map.on("load", res));
      try { console.log('[renderer] maplibre version=', maplibregl.version, 'style.version=', (map.getStyle()||{}).version); } catch {}
      // Borders: ask Node side to provide GeoJSON (local file or server-side fetch)
      const borderData = await window.__nodeGetBordersGeoJSON();

      // Filter the feature for the requested ISO3 (ADM0_A3/ISO_A3/ISO3166-1-Alpha-3 cover common fields)
      const ISO3 = (program.border?.isoA3 || '').toString().toUpperCase();
      const feats = borderData.features.filter(f => {
        const p = f.properties || {};
        return [p.ADM0_A3, p.ISO_A3, p["ISO3166-1-Alpha-3"], p.iso_a3]
          .map(x => (x || "").toString().toUpperCase())
          .includes(ISO3);
      });
      let matched = feats;
      if (!matched.length) {
        // Fallback: match by 'name' using a small ISO3->Name map (helps with world-atlas datasets)
        const isoToName = { ESP: 'Spain', FRA: 'France', DEU: 'Germany', ITA: 'Italy', GBR: 'United Kingdom', USA: 'United States of America', MEX: 'Mexico', CAN: 'Canada', BRA: 'Brazil', AUS: 'Australia', JPN: 'Japan', CHN: 'China', IND: 'India', RUS: 'Russia' };
        const target = (isoToName[ISO3] || '').toUpperCase();
        if (target) {
          matched = borderData.features.filter(f => ((f.properties?.name || '').toString().toUpperCase()) === target);
          if (!matched.length) {
            // Some datasets use NAME or NAME_EN
            matched = borderData.features.filter(f => {
              const p = f.properties || {};
              return [p.NAME, p.NAME_EN, p.name_long].map(x => (x||'').toString().toUpperCase()).includes(target);
            });
          }
          console.log(`[renderer] fallback name match for ${ISO3}=${target} features=${matched.length}`);
        }
      }
      console.log(`[renderer] border match iso3=${ISO3} features=${matched.length}`);

      const highlight = { type: "FeatureCollection", features: matched };
      map.addSource("border_src", { type: "geojson", data: highlight });

      // Build linework from polygons for crisp outlines and tracing
      function polygonToLines(fc) {
        const out = { type: 'FeatureCollection', features: [] };
        for (const f of fc.features) {
          const g = f.geometry;
          const props = f.properties || {};
          if (!g) continue;
          if (g.type === 'Polygon') {
            for (const ring of g.coordinates) {
              out.features.push({ type: 'Feature', properties: props, geometry: { type: 'LineString', coordinates: ring } });
            }
          } else if (g.type === 'MultiPolygon') {
            for (const poly of g.coordinates) {
              for (const ring of poly) {
                out.features.push({ type: 'Feature', properties: props, geometry: { type: 'LineString', coordinates: ring } });
              }
            }
          }
        }
        return out;
      }
      const borderLines = polygonToLines(highlight);
      console.log(`[renderer] border polygons=${highlight.features.length}, lineFeatures=${borderLines.features.length}`);
      try {
        map.addSource("border_lines_src", { type: 'geojson', data: borderLines, lineMetrics: true });
      } catch (e) { console.error('[renderer] addSource border_lines_src error', e?.message || e); }

      // Base border outline (initially hidden unless showDuringZoom)
      try { map.addLayer({
        id: "border_line",
        type: "line",
        source: "border_lines_src",
        paint: {
          "line-color": getBorderColor(program),
          "line-width": program.border.strokeWidth ?? 4,
          // Start hidden; we will reveal after trace unless showDuringZoom is true
          "line-opacity": 0,
          "line-blur": 0
        },
        layout: {
          "line-join": "round",
          "line-cap": "round"
        }
      }); console.log('[renderer] added layer border_line'); } catch (e) { console.error('[renderer] addLayer border_line error', e?.message || e); }

      // Respect showDuringZoom: optionally show faint/visible outline during camera move
      const showDuringZoom = !!(program.border?.showDuringZoom);
      try {
        map.setPaintProperty('border_line', 'line-opacity', showDuringZoom ? (program.border?.opacity ?? 1) : 0);
        console.log(`[renderer] border_line initial opacity set to ${showDuringZoom ? (program.border?.opacity ?? 1) : 0}`);
      } catch (e) { console.error('[renderer] set opacity border_line error', e?.message || e); }

      // Disable transitions to avoid flashes
      try { map.setPaintProperty('border_line', 'line-opacity-transition', { duration: 0, delay: 0 }); } catch {}

      // Drawn border layer (progressively revealed via line-gradient)
      try { map.addLayer({
        id: 'border_drawn',
        type: 'line',
        source: 'border_lines_src',
        paint: {
          'line-color': getBorderColor(program),
          'line-width': (program.border.strokeWidth ?? 4),
          'line-opacity': 0.0
        },
        layout: { 'line-join': 'round', 'line-cap': 'round' }
      }); console.log('[renderer] added layer border_drawn'); } catch (e) { console.error('[renderer] addLayer border_drawn error', e?.message || e); }
      try { map.setPaintProperty('border_drawn', 'line-opacity-transition', { duration: 0, delay: 0 }); } catch {}
      try { map.setPaintProperty('border_drawn', 'line-gradient-transition', { duration: 0, delay: 0 }); } catch {}

      // Trace layer (animated moving highlight)
      try { map.addLayer({
        id: 'border_trace',
        type: 'line',
        source: 'border_lines_src',
        paint: {
          'line-color': getTraceColor(program),
          'line-width': (program.border.strokeWidth ?? 4) + getTraceDelta(program),
          'line-opacity': 0.0
        },
        layout: { 'line-join': 'round', 'line-cap': 'round' }
      }); console.log('[renderer] added layer border_trace'); } catch (e) { console.error('[renderer] addLayer border_trace error', e?.message || e); }
      try { map.setPaintProperty('border_trace', 'line-opacity-transition', { duration: 0, delay: 0 }); } catch {}
      try { map.setPaintProperty('border_trace', 'line-gradient-transition', { duration: 0, delay: 0 }); } catch {}

      // Label restriction util
      function applyLabelRestriction() {
        try {
          const geom = highlight.features[0]?.geometry;
          if (!geom) return;
          const style = map.getStyle();
          if (!style || !style.layers) return;
          for (const layer of style.layers) {
            if (layer.type === 'symbol') {
              map.setFilter(layer.id, ['within', { type: geom.type, coordinates: geom.coordinates }]);
            }
          }
        } catch (e) { /* ignore */ }
      }

      // Warm up one render
      if (program.labels?.restrictToCountry && program.labels?.applyAt === 'always') {
        applyLabelRestriction();
      }
      await new Promise(res => map.once("idle", res));

      // Hubble.gl: create WebM encoder (handle different global/casing)
      const hub = window.hubble || window.Hubble || window.hubblegl || window.HubbleGL || {};
      const WebMEncoder = hub.WebMEncoder || hub.WebmEncoder;
      if (typeof WebMEncoder !== 'function') {
        const keys = Object.keys(hub);
        throw new Error("Hubble.gl WebMEncoder not found. Exports: " + JSON.stringify(keys));
      }
      const encoder = new WebMEncoder({ framerate: fps });
      await encoder.start();
      // Progress logging header
      const effPixelRatio = Math.max(1, Math.min(4, Number(program.output.pixelRatio) || 2));
      console.log(`[progress] start: frames=${frameCount}, fps=${fps}, waitForTiles=${program.output.waitForTiles}, pixelRatio=${effPixelRatio}`);
      const progressEvery = Math.max(30, Math.floor(frameCount / 10));

      // Optional auto-fit for final keyframe framing
      try {
        if (program.animation?.fitFinalToBorder) {
          const geom = highlight.features[0]?.geometry;
          if (geom) {
            const coords = (geom.type === 'Polygon') ? geom.coordinates.flat(1) : geom.coordinates.flat(2);
            const lons = coords.map(c => c[0]);
            const lats = coords.map(c => c[1]);
            const minLon = Math.min(...lons), maxLon = Math.max(...lons);
            const minLat = Math.min(...lats), maxLat = Math.max(...lats);
            const pad = Number(program.animation?.fitPaddingPx ?? 80);
            const cam = map.cameraForBounds([[minLon, minLat],[maxLon, maxLat]], { padding: pad });
            if (cam && program.camera?.keyframes?.length) {
              const last = program.camera.keyframes[program.camera.keyframes.length - 1];
              const arr = toLngLatArray(cam.center);
              if (arr) last.center = arr;
              if (isFinite(cam.zoom)) last.zoom = cam.zoom;
            }
          }
        }
      } catch (e) { console.warn('[renderer] auto-fit final camera failed', e?.message || e); }

      // Execute phases in declared order
      const phases = (program.animation?.phases && program.animation.phases.length) ? program.animation.phases : ['zoom','trace','hold'];
      console.log("phases are", phases)
      for (const phase of phases) {
        console.log("current phase is", phase)
        if (phase === 'zoom') await runZoomPhase(map, encoder, program, fps, duration, frameCount, ease);
        else if (phase === 'wait') await runWaitPhase(map, encoder, Number(program.animation?.waitBeforeTraceMs || 0), fps);
        else if (phase === 'trace') await runTracePhase(map, encoder, program, fps);
        else if (phase === 'hold') await runHoldPhase(map, encoder, program, fps);
      }

      // After zoom completes, optionally restrict labels and draw tracing
    //   if (program.labels?.restrictToCountry && (program.labels?.applyAt !== 'always')) {
    //     console.log("country label restriction")
    //     applyLabelRestriction();
    //     await new Promise(res => map.once('idle', res));
    //   }
    //   if (program.border?.traceAfterZoom) {
    //     console.log("tracing border")
    //     const traceMs = program.border?.traceDurationMs ?? 3000;
    //     const traceFrames = Math.max(1, Math.ceil((traceMs / 1000) * fps));
    //     console.log(`[progress] trace-start: frames=${traceFrames}, ms=${traceMs}`);
    //     const traceEvery = Math.max(15, Math.floor(traceFrames / 5));
    //     // Ensure static outline is hidden during trace if not supposed to showDuringZoom
    //     if (!showDuringZoom) {
    //       try { map.setPaintProperty('border_line', 'line-opacity', 0); } catch {}
    //       // Keep border_drawn hidden until gradient is applied to avoid flash
    //       try { map.setPaintProperty('border_drawn', 'line-opacity', 0); } catch {}
    //     }
    //     for (let j = 0; j < traceFrames; j++) {
    //       const prog = (j / Math.max(1, traceFrames - 1) ) + 0.03;
    //       const gradTrace = [
    //         'interpolate', ['linear'], ['line-progress'],
    //         0, 'rgba(255,255,255,0.0)',
    //         Math.max(0, prog - 0.02), 'rgba(255,255,255,0.0)',
    //         prog, 'rgba(255,255,255,1.0)',
    //         Math.min(1, prog + 0.02), 'rgba(255,255,255,0.0)',
    //         1, 'rgba(255,255,255,0.0)'
    //       ];
    //       const gradDrawn = [
    //         'interpolate', ['linear'], ['line-progress'],
    //         0, 'rgba(255,204,0,1.0)',
    //         Math.max(0, prog), 'rgba(255,204,0,1.0)',
    //         Math.min(1, prog + 0.001), 'rgba(255,204,0,0.0)',
    //         1, 'rgba(255,204,0,0.0)'
    //       ];
    //       try {
    //         map.setPaintProperty('border_trace', 'line-gradient', gradTrace);
    //         map.setPaintProperty('border_trace', 'line-opacity', 1.0);
    //         // progressively reveal the drawn border behind the tracer
    //         map.setPaintProperty('border_drawn', 'line-gradient', gradDrawn);
    //         map.setPaintProperty('border_drawn', 'line-opacity', program.border?.opacity ?? 1);
    //       } catch (e) {
    //         console.error('[renderer] trace setPaintProperty error', e?.message || e);
    //         // Fallback: show static trace if gradient not supported
    //         try {
    //           map.setPaintProperty('border_trace', 'line-gradient', undefined);
    //           map.setPaintProperty('border_trace', 'line-color', '#ffffff');
    //           map.setPaintProperty('border_trace', 'line-opacity', 1.0);
    //           // Show static border fully if gradient not supported
    //           map.setPaintProperty('border_drawn', 'line-gradient', undefined);
    //           map.setPaintProperty('border_drawn', 'line-color', '#ffcc00');
    //           map.setPaintProperty('border_drawn', 'line-opacity', program.border?.opacity ?? 1);
    //         } catch (e2) {
    //           console.error('[renderer] trace fallback error', e2?.message || e2);
    //         }
    //       }
    //       await new Promise(res => map.once('idle', res));
    //       await encoder.add(map.getCanvas());
    //       if (j % traceEvery === 0 || j === traceFrames - 1) {
    //         const done = j + 1;
    //         const left = traceFrames - done;
    //         const pct = Math.round((done / traceFrames) * 100);
    //         console.log(`[progress] trace ${done}/${traceFrames} (${pct}%), left=${left}`);
    //       }
    //     }
    //     try { map.setPaintProperty('border_trace', 'line-opacity', 0.0); } catch {}
    //     // After tracing completes, ensure static border is fully visible (via border_drawn) if desired
    //     const showAfter = (program.border?.showStaticAfterTrace !== false);
    //     if (showAfter) {
    //       try {
    //         map.setPaintProperty('border_drawn', 'line-gradient', undefined);
    //         map.setPaintProperty('border_drawn', 'line-color', '#ffcc00');
    //         map.setPaintProperty('border_drawn', 'line-opacity', program.border?.opacity ?? 1);
    //         console.log('[renderer] static border set after trace');
    //       } catch (e) { console.error('[renderer] reveal static border error', e?.message || e); }
    //     }

    //     // Hold for a few seconds after trace completes
    //     const holdMs = Math.max(0, Number(program.border?.traceHoldMs ?? 2000));
    //     const holdFrames = Math.ceil((holdMs / 1000) * fps);
    //     if (holdFrames > 0) {
    //       console.log(`[progress] hold-start: frames=${holdFrames}, ms=${holdMs}`);
    //       for (let h = 0; h < holdFrames; h++) {
    //         await new Promise(res => requestAnimationFrame(res));
    //         await encoder.add(map.getCanvas());
    //       }
    //       console.log('[progress] hold-done');
    //     }
    //   }

      console.log('[progress] encode-save-start');
      const blob = await encoder.save(); // Blob (video/webm)
      console.log('[progress] encode-save-done bytes=' + (blob?.size ?? 'unknown'));
      const arrbuf = await blob.arrayBuffer();
      // Puppeteer binding is safer with plain arrays vs typed arrays.
      const byteArray = Array.from(new Uint8Array(arrbuf));
      console.log('[progress] deliver-bytes-start size=' + byteArray.length);
      await window.__nodeDeliverWebM(byteArray);
      console.log('[progress] deliver-bytes-done');
    };
  </script>
</body>
</html>
